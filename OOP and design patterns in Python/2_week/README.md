# ***Неделя 2***
## Задание по программированию: Создание базовых классов
___
В этом задании вам даны 3 класса A, B, C, имеющие сходный (но не одинаковый) интерфейс. Вам необходимо создать абстрактный базовый класс Base и построить корректную схему наследования.

При выполнении следует избегать дублирования кода, и стараться следовать SOLID принципам ООП.

Кроме того, рекомендуется самостоятельно тестировать код перед отправкой, а также при написании следовать стандарту PEP 8.
```python
import math


class Base:

    pass


class A:
    def __init__(self, data, result):
        self.data = data
        self.result = result

    def get_answer(self):
        return [int(x >= 0.5) for x in self.data]

    def get_score(self):
        ans = self.get_answer()
        return sum([int(x == y) for (x, y) in zip(ans, self.result)]) \
            / len(ans)

    def get_loss(self):
        return sum(
            [(x - y) * (x - y) for (x, y) in zip(self.data, self.result)])


class B:
    def __init__(self, data, result):
        self.data = data
        self.result = result

    def get_answer(self):
        return [int(x >= 0.5) for x in self.data]

    def get_loss(self):
        return -sum([
            y * math.log(x) + (1 - y) * math.log(1 - x)
            for (x, y) in zip(self.data, self.result)
        ])

    def get_pre(self):
        ans = self.get_answer()
        res = [int(x == 1 and y == 1) for (x, y) in zip(ans, self.result)]
        return sum(res) / sum(ans)

    def get_rec(self):
        ans = self.get_answer()
        res = [int(x == 1 and y == 1) for (x, y) in zip(ans, self.result)]
        return sum(res) / sum(self.result)

    def get_score(self):
        pre = self.get_pre()
        rec = self.get_rec()
        return 2 * pre * rec / (pre + rec)


class C:
    def __init__(self, data, result):
        self.data = data
        self.result = result

    def get_answer(self):
        return [int(x >= 0.5) for x in self.data]

    def get_score(self):
        ans = self.get_answer()
        return sum([int(x == y) for (x, y) in zip(ans, self.result)]) \
            / len(ans)

    def get_loss(self):
        return sum([abs(x - y) for (x, y) in zip(self.data, self.result)])
```

## Задание по программированию: Создание иерархий классов
___
В этом задании вам необходимо сделать рефакторинг уже реализованной программы - заставки для скринсейвера. Исходный код программы можно ниже:
![screen_saver](https://github.com/DanilKhardi/Python-Specialization-by-Coursera/blob/main/OOP%20and%20design%20patterns%20in%20Python/2_week/screen_saver.gif)

Для работы программы необходима библиотека **PyGame**.

Программа запускается из консоли, как обычный Python скрипт:

$ python3 screen.py

В открывшемся окне программы доступны следующие команды управления:
- **F1** - показать справку по командам

- **R**  - рестарт

- **P**  - пауза, снять/поставить

- **num+**  - увеличить количество точек «сглаживания»

- **num-**  - уменьшить количество точек «сглаживания»

- **mouse left**  - добавить «опорную» точку
  
По умолчанию при старте программы «опорные» точки отсутствуют и программа находится в состоянии паузы (движение кривой выключено). Для добавления точек сделайте несколько кликов левой клавишей мыши в любом месте окна программы. Отрисовка кривой произойдет, когда точек на экране станет больше двух. Нажмите клавишу **P**, чтобы включить движение кривой.

**Ваша задача:**
1. Изучить документацию к библиотеке pygame и код программы. Понять механизм работы программы (как происходит отрисовка кривой, перерасчет точек сглаживания и другие нюансы реализации программы)

2. Провести рефакторниг кода, переписать программу в ООП стиле с использованием классов и наследования.

- Реализовать класс 2-мерных векторов Vec2d [1]. В классе следует определить методы для основных математических операций, необходимых для работы с вектором: Vec2d.__add__ (сумма), Vec2d.__sub__ (разность), Vec2d.__mul__ (произведение на число). А также добавить возможность вычислять длину вектора с использованием функции len(a) и метод int_pair, который возвращает кортеж из двух целых чисел (текущие координаты вектора).

- Реализовать класс замкнутых ломаных Polyline с методами отвечающими за добавление в ломаную точки (Vec2d) c её скоростью, пересчёт координат точек (set_points) и отрисовку ломаной (draw_points). Арифметические действия с векторами должны быть реализованы с помощью операторов, а не через вызовы соответствующих методов.

- Реализовать класс Knot (наследник класса Polyline), в котором добавление и пересчёт координат инициируют вызов функции get_knot для расчёта точек кривой по добавляемым «опорным» точкам [2].

- Все классы должны быть самостоятельными и не использовать внешние функции.

- Реализовать дополнительный функционал (выполнение требований этого пункта предоставляет возможность потренировать свои навыки программирования и позволяет получить дополнительные баллы в этом задании). К дополнительным задачам относятся: реализовать возможность удаления «опорной» точки из кривой, реализовать возможность отрисовки на экране нескольких кривых, реализовать возможность ускорения/замедления скорости движения кривой(-ых).