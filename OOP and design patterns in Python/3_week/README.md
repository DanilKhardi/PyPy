# ***Неделя 3***
## ***Задание по программированию: Создание декоратора класса***
___
Представьте себя ненадолго разработчиком компьютерной игры в стиле фэнтези. Вам поручено написать реализацию системы эффектов, которые могут быть наложены на героя вашей игры.

В игре есть герой, который обладает некоторым набором характеристик. Класс героя описан следующим образом:
```python
class Hero:
    def __init__(self):
        self.positive_effects = []
        self.negative_effects = []
        self.stats = {
            "HP": 128,  # health points
            "MP": 42,  # magic points, 
            "SP": 100,  # skill points
            "Strength": 15,  # сила
            "Perception": 4,  # восприятие
            "Endurance": 8,  # выносливость
            "Charisma": 2,  # харизма
            "Intelligence": 3,  # интеллект
            "Agility": 8,  # ловкость 
            "Luck": 1  # удача
        }

    def get_positive_effects(self):
        return self.positive_effects.copy()

    def get_negative_effects(self):
        return self.negative_effects.copy()

    def get_stats(self):
        return self.stats.copy()
```
К основным характеристикам относятся: Сила (Strength), Восприятие (Perception), Выносливость (Endurance), Харизма (Charisma), Интеллект (Intelligence), Ловкость (Agility), Удача (Luck).

Враги и союзники могут накладывать на героя положительные и отрицательные эффекты. Эти эффекты изменяют характеристики героя,  увеличивая или уменьшая значения определенных характеристик, в зависимости от того какие эффекты были наложены.  На героя можно накладывать бесконечно много эффектов, действие одинаковых эффектов суммируется. Игрок должен знать, какие положительные и какие отрицательные эффекты на него были наложены и в каком порядке. Названия эффектов совпадают с названиями классов.

За получение данных о текущем состоянии героя отвечают методы get_stats, get_positive_effects,  get_negative_effects.

***Вам необходимо написать систему декораторов, представленную на UML-диаграмме:***
![decorator_uml](https://github.com/DanilKhardi/Python-Specialization-by-Coursera/blob/main/OOP%20and%20design%20patterns%20in%20Python/3_week/Decorator_UML.jpg)<br>

## Описание эффектов:
**Берсерк (Berserk) -**
- Увеличивает характеристики: Сила, Выносливость, Ловкость, Удача на 7;
- уменьшает характеристики: Восприятие, Харизма, Интеллект на 3;
- количество единиц здоровья увеличивается на 50.

**Благословение (Blessing) -**
- увеличивает все основные характеристики на 2.

**Слабость (Weakness) -**
- уменьшает характеристики: Сила, Выносливость, Ловкость на 4.

**Сглаз (EvilEye) -**
- уменьшает  характеристику Удача на 10.

**Проклятье (Curse) -**
- уменьшает все основные характеристики на 2.
  
**При выполнении задания необходимо учитывать, что:**
- изначальные характеристики базового объекта не должны меняться.
- изменения характеристик и накладываемых эффектов (баффов/дебаффов) должны происходить динамически, то есть вычисляться при вызове методов get_stats, get_positive_effects, get_negative_effects
- абстрактные классы AbstractPositive,  AbstractNegative и соответственно их потомки могут принимать любой параметр base при инициализации объекта (_ _ init _ _ (self, base))
  
**Пример работы:**
```python
>>> from deco import *
>>> # создаем героя
>>> hero = Hero()
>>> hero.get_stats()
{'HP': 128, 'MP': 42, 'SP': 100, 'Strength': 15, 'Perception': 4, 'Endurance': 8, 'Charisma': 2, 'Intelligence': 3, 'Agility': 8, 'Luck': 1}
>>> hero.stats
{'HP': 128, 'MP': 42, 'SP': 100, 'Strength': 15, 'Perception': 4, 'Endurance': 8, 'Charisma': 2, 'Intelligence': 3, 'Agility': 8, 'Luck': 1}
>>> hero.get_negative_effects()
[ ]
>>> hero.get_positive_effects()
[ ]
>>> # накладываем эффект

>>> brs1 = Berserk(hero)
>>> brs1.get_stats()
{'HP': 178, 'MP': 42, 'SP': 100, 'Strength': 22, 'Perception': 1, 'Endurance': 15, 'Charisma': -1, 'Intelligence': 0, 'Agility': 15, 'Luck': 8}
>>> brs1.get_negative_effects()
[ ]
>>> brs1.get_positive_effects()
['Berserk']

>>> # накладываем эффекты
>>> brs2 = Berserk(brs1)

>>> cur1 = Curse(brs2)

>>> cur1.get_stats()
{'HP': 228, 'MP': 42, 'SP': 100, 'Strength': 27, 'Perception': -4, 'Endurance': 20, 'Charisma': -6, 'Intelligence': -5, 'Agility': 20, 'Luck': 13}
>>> cur1.get_positive_effects()
['Berserk', 'Berserk']
>>> cur1.get_negative_effects()
['Curse']
>>> # снимаем эффект Berserk
>>> cur1.base = brs1
>>> cur1.get_stats()
{'HP': 178, 'MP': 42, 'SP': 100, 'Strength': 20, 'Perception': -1, 'Endurance': 13, 'Charisma': -3, 'Intelligence': -2, 'Agility': 13, 'Luck': 6}
>>> cur1.get_positive_effects()
['Berserk']
>>> cur1.get_negative_effects()
['Curse']
```
## ***Задание по программированию: Создание адаптера для класса***
___
Вы продолжаете писать игру, и настало время разобраться с расчетом освещенности на карте. Так как это не совсем тривиальная задача, вы хотели бы использовать готовое решение, а не писать свое собственное. Вам удалось найти готовый класс, который решает задачу, однако интерфейс этого класса не совместим с вашей игрой.

Вам нужно написать адаптер, который позволил бы использовать найденный вами класс совместно с вашей системой.

Интерфейс класса выглядит следующим образом:
```python
class Light:
    def __init__(self, dim):
        self.dim = dim
        self.grid = [[0 for i in range(dim[0])] for _ in range(dim[1])]
        self.lights = []
        self.obstacles = []
        
    def set_dim(self, dim):
        self.dim = dim
        self.grid = [[0 for i in range(dim[0])] for _ in range(dim[1])]
    
    def set_lights(self, lights):
        self.lights = lights
        self.generate_lights()
    
    def set_obstacles(self, obstacles):
        self.obstacles = obstacles
        self.generate_lights()
        
    def generate_lights(self):
        return self.grid.copy()
```
Интерфейс системы выглядит следующим образом:
```python
class System:
    def __init__(self):
        self.map = self.grid = [[0 for i in range(30)] for _ in range(20)]
        self.map[5][7] = 1 # Источники света
        self.map[5][2] = -1 # Стены
    
    def get_lightening(self, light_mapper):
        self.lightmap = light_mapper.lighten(self.map)
```
Класс Light создает в методе __init__ поле заданного размера. За размер поля отвечает параметр, представляющий из себя кортеж из 2 чисел. Элемент dim[1] отвечает за высоту карты, dim[0] за ее ширину. Метод set_lights устанавливает массив источников света с заданными координатами и просчитывает освещение. Метод set_obstacles устанавливает препятствия аналогичным образом. Положение элементов задается списком кортежей. В каждом элементе кортежа хранятся 2 значения: elem[0] -- координата по ширине карты и elem[1] -- координата по высоте соответственно. Метод generate_lights рассчитывает освещенность с учетом источников и препятствий.

В системе в конструкторе создается двухмерная, карта, на которой источники света обозначены как 1, а препятствия как -1. Метод get_lightening принимает в качестве аргумента объект, который должен посчитывать освещение. У объекта вызывается метод lighten, который принимает карту объектов и источников света и возвращает карту освещенности.

Вам необходимо написать адаптер MappingAdapter. Прототип класса вам дан в качестве исходного кода.
```python
class MappingAdapter:
    def __init__(self, adaptee):
        pass

    def lighten(self, grid):
        pass
```
## ***Задание по программированию: Паттерн Наблюдатель***
___
Продолжая работу над игрой, вы добрались до системы достижений. Иногда по сценарию игры требуется наградить игрока за то, что он достигает определенного результата в игре. Это может быть, например: прохождение всех заданий в игре, достижение определенного уровня, совершение какого-то сложного действия и т.д.

У каждой игры есть движок и интерфейс пользователя. Эти два компонента работают параллельно и взаимодействуют друг с другом. Достижения генерируются движком игры, а отображаются пользовательским интерфейсом. Кроме того, на современных игровых площадках, таких как Steam, Google Play, также отображаются достижения, полученные игроком. Реализуется это с помощью паттерна Наблюдатель.

В реализации нашей игры есть движок Engine, который может создавать уведомления о достижениях. Пример достижения, которое генерирует движок:

`{"title": "Покоритель", "text": "Дается при выполнении всех заданий в игре"}`

Вам необходимо написать обертку над движком, которая будет иметь возможность подписывать наблюдателей и рассылать им уведомления. Вы так же должны написать реализацию классов иерархии наблюдателей.

**Иерархия классов приведена на следующей UML диаграмме:**
![observer_uml](https://github.com/DanilKhardi/Python-Specialization-by-Coursera/blob/main/OOP%20and%20design%20patterns%20in%20Python/3_week/Observer_UML.jpg)<br>

Иерархия наблюдателей включает в себя **AbstractObserver**(абстрактный наблюдатель) от которого унаследованы два наблюдателя **ShortNotificationPrinter** и **FullNotificationPrinter**. В атрибуте **achievements** у **ShortNotificationPrinter** хранится множество названий полученных достижений, а у **FullNotificationPrinter** - список достижений в том порядке, в котором они генерируются **Engine**. Обратите внимание, что каждое достижение должно быть уникальным (то есть учтено только один раз).

Метод update не должен возвращать никаких значений, он должен только изменять значение атрибута achievements.